## Ftrace tools

目前，我们已经讲了 `ftrace` 使用 以及 动态插桩和内核设计的核心实现机制，本章节，我们回到用户视角，为大家介绍更多的 `ftrace`的使用工具

### 前情回顾

- `tracing` 子系统 主要通过`tracefs` 和用户态交互 

- 理解`tracer` 的概念，是一个广义的`tracing 机制` 

- 理解`ftrace`的实现原理，`ftrace` 是 `tracing`子系统实现的底座 

### trace-cmd

[github源码版本较老](https://github.com/rostedt/trace-cmd/tree/master)

[官方地址](https://www.trace-cmd.org/)

trace-cmd 提供了 一个简洁的 命令集成和封装，可以帮助我们完成 和 `tracefs`的交互

#### 安装

如果你是在ubuntu 这类 发行版本的操作系统上，可以找到对应发行版本的安装方法；

如果是嵌入式环境，需要自行通过交叉编译，本次内容不覆盖

```shell
apt install trace-cmd
```

#### 使用说明

命令其实都可以通过 help 查看

```shell
#trace-cmd --help
```

所有命令的实现 其实我们甚至可以通过阅读其源码，知道它在做什么，举例说明： 

```shell
#trace-cmd show  --help
```

https://github.com/rostedt/trace-cmd/blob/master/tracecmd/trace-show.c

 trace-cmd 只是用来简化对 `tracefs`操作的前端工具， 它的工作，我们自己也可以通过命令行手动实现，就不在这里赘述

### kernelshark

更多情况下，`kernel shark` 是我们更加常用的工具，`kernelshark`是基于 `trace-cmd` 的前端图形显示工具 ，主要能力在于对 `trace`文件的可视化显示 

建议可以在本地或者远端安装`kernelshark`

```shell
apt install kernelshark
```



#### 使用示例

[Using KernelShark to analyze the real-time scheduler ](https://lwn.net/Articles/425583/)

在开发 Linux 实时调度程序的算法时，需要考虑实时调度器在处理高优先级进程唤醒时的一种复杂性和权衡，特别是在多 CPU 系统上进程迁移的影响。：

当一个高优先级的实时进程在某个 CPU 上唤醒，而该 CPU 正在运行一个低优先级的实时进程，并且两个进程都允许在多个 CPU 上运行时，系统会面临以下选择：

1. **直接唤醒高优先级进程**：可以选择在当前 CPU 上直接唤醒高优先级进程，从而迫使低优先级进程被调度出去。然而，这样做的代价是可能会导致低优先级的实时进程被迁移到另一个 CPU 上，而那个 CPU 的缓存对这个实时进程来说是冷的（即，没有之前进程运行时的数据缓存）。

2. **避免缓存冷化**：理论上，这种直接切换可能导致效率降低，因为高优先级进程会在一个缓存冷的 CPU 上启动，低优先级进程也可能被迁移到另一个缓存冷的 CPU 上，这就破坏了两者的缓存局部性。



经过一番争论，社区最终决定将高优先级进程迁移到运行最低优先级任务（或根本没有任务）的 CPU 上，并在那里唤醒它。 一段时间后，在代码被纳入主线后，我开始质疑这一决定，尽管我是为之奋斗的人。 随着 Ftrace 的推出，我们现在有了一种实用工具来真正检查这一决定所产生的影响。



1. **假设唤醒任务通常是缓存冷的**：
   
   - 在最初的假设下，如果一个高优先级任务从睡眠状态中唤醒，通常认为它可能是“缓存冷”的，因为在它睡眠期间，其他任务可能已经填充或刷新了 CPU 缓存。
   - 比如，定期唤醒的任务往往会变成缓存冷的，因为在其下次唤醒时，其他任务的执行可能已经替换掉它的缓存数据。

2. **不同唤醒原因的影响**：
   
   - 如果高优先级任务是由于被阻塞在互斥锁（mutex）上而进入睡眠状态，则情况可能不同。
   - 当它等待某个锁时，如果有另一个实时任务在相同的 CPU 上运行，一旦高优先级任务重新获得锁并唤醒，它仍然可能保持“缓存热”（cache hot），因为它最近在这个 CPU 上运行，缓存中可能还保留着它的相关数据。



我总结如下：

-  实时系统中，具备多亲和性的高优先级任务 要能够抢占低优先级任务的CPU

-  抢占发生时，需要决策抢占哪个 CPU上的任务，低优先级为主 ？ 

- 抢占发生时，需要考虑缓存的性能开销， 抢占哪个CPU 的缓存最有利



在大多数实时程序中，互斥通常会保持很短的时间。`PREEMPT_RT` 补丁将自旋锁转换为互斥锁，而这些互斥锁会在非常小的代码段中保持，所有自旋锁都应如此。 仅仅因为一个任务阻塞了互斥，就将其迁移，会增加这些锁对吞吐量的影响。 为什么要因为高优先级任务阻塞并不得不等待另一个任务运行而对它进行更多惩罚呢？

在决定修改代码之前，我需要一个测试用例来证明，如果不抢占低优先级任务，而是移动高优先级任务，会导致高优先级任务在出现锁竞争时在 CPU 上乒乓乱转。 如果高优先级任务只是遇到了低优先级实时任务的锁竞争，那么就不应该对它进行惩罚（迁移）。 此外，了解改变这一决定对锁争用情况下所有任务的迁移总数有何影响也会有所帮助。



##### 第一次尝试

有了一个 4 处理器的电脑，我开始编写可能导致这种情况的测试用例，并使用 Ftrace 分析结果。 第一个测试案例是创建 5 个线程（比 CPU 多一个）和 4 个 pthread 互斥锁。 让所有线程从`barrier`等待中唤醒，然后依次抓取每个锁循环 50 次，并做`small busy loop`。 该测试名为 migrate.c。
